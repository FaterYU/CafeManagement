# 技术报告

## 引言

本项目为咖啡店的收银提供了一套较为完整的解决方案，包括客户端和管理端。本系统提供了咖啡店商品和订单信息的增添、修改、查询，同时也提供了收入数据的可视化分析。
本项目团队由8人组成，分别是郑誉、曹宏、廖若凡、黄会清、雷稞焮、王浩然、陈培璋、潘厚元。团队中系统原型设计由曹宏、黄会清、雷稞焮负责，系统前端设计由郑誉、廖若凡、王浩然、陈培璋、潘厚元负责，系统后端设计和应用部署由郑誉负责。
本项目使用git版本管理工具进行项目管理，内部会议两周一次。在开发协作方面原型设计、前端设计、后端设计三个部分同步进行，由其中一名全栈开发的项目成员进行协调需求。开发过程中优先保证功能的实现再考虑系统界面的美化，最后再补充相关的文档信息。

## 项目计划和风险评估

本项目的障碍主要由以下四个部分组成：

1. 系统的跨平台应用。本系统应用场景为咖啡店实体店，需要为顾客提供简单直观的交互方式。对于本系统客户端来说，最直观的交互载体是平板电脑。对于本系统管理端来说，较为合适的载体是PC端。鉴于平板电脑市场上主要的操作系统为iPadOS和安卓，PC端主流系统为Windows、Linux、MacOS，因此满足跨平台使用是本系统的必要需求。
2. 系统的支付接口调用。自主开发支付接口存在普及性低，用户少，安全性不高的缺点，因此调用主流的支付方式的接口以此提供订单支付功能是最合适的选择。然而，主流支付方式的接口各不相同，考虑到目前产品处于验证阶段，需要一个包含开发者环境的支付方式接口进行测试。
3. 系统的安全性。本系统既涉及金钱交易的过程，又涉及订单生成的功能，因此在生产环境中对本系统的要求是非常苛刻的。本系统的安全性有以下两个最低要求，首先要能防止从TCP/IP链路中的MITM，避免用户可以通过技术手段直接修改系统后端数据库，防止发生订单产生后在不支付的条件下对后端数据库进行直接的SQL注入修改该订单的付款字段从而造成店铺直接经济损失的情况。其次要防止客户端的数据泄露，避免用户直接通过管理端的数据接口获取店铺商品信息和订单信息。
4. 团队中仅有一名前后端全栈开发的成员以及一名前端开发的成员有开发经验，项目的推进需要为没有基础的同学预留足够的学习时间，并且考虑他们的学习成本。

针对以上开发的障碍，我们团队计划分别通过以下方法进行克服：

1. 使用Electron这个构建跨平台应用程序的框架进行打包和分发跨平台的应用程序。Electron is a framework for building desktop applications using JavaScript, HTML, and CSS. By embedding Chromium and Node.js into its binary, Electron allows you to maintain one JavaScript codebase and create cross-platform apps that work on Windows, macOS, and Linux — no native development experience required. 在使用Electron框架以后，团队成员能更专注于系统功能的开发中，除了负责构建应用的一名成员，其他成员可以完全不需要考虑部署在多平台的难度。
2. 对比了多个主流支付接口的开发者环境后，我们团队最终选择使用支付宝的沙箱环境作为本系统在产品验证阶段的支付环境。沙箱环境是支付宝开放平台为开发者提供的与生产环境完全隔离的联调测试环境，开发者在沙箱环境中完成的接口调用不会对生产环境中的数据造成任何影响。通过支付宝沙箱环境，我们可以在不真正进行金钱交易的情况下测试支付功能是否在正常运行。
3. 针对系统的安全性设计，我们采取三种方法保证系统的安全。第一，对后端重要的数据传输做RSA与AES联合加密，以保证关键信息即使被抓包也不会马上被破解。第二，在后端设计中绝对避免将支付接口暴露，从而在根源上保证支付信息的可靠性。第三，在后端接口的设计上进行数据验证，以防止SQL注入。
4. 考虑大部分成员的学习成本，团队在技术栈的选择上舍弃了相对高效且拓展性极高的Qt平台，而选择了更容易上手的Vue3+Node.js+MySQL的JavaScript开发框架。考虑到本系统作为实体店的收银系统，功能上并不需要过多的拓展性，因此舍弃了一定的开发效率，以换取更多成员能更快地参与到本系统的开发工作中。

在本系统中，项目计划的最低预期为：

1. 自由添加饮品条目，备注饮品的详细信息；
2. 在用户端简单直观的选择饮品，结账时快速帮助用户计算账单总金额；
3. 生成账单时自动向后台添加交易记录，记录交易的总金额、收款额、找零额、支付方式，便于在管理端进行快速核对点账；
4. 管理端与用户端分离，保证业务的安全性和准确性；
5. 管理端个性化的查询系统，提供可进行条件筛选的交易数据查询和统计，以对特定时间段的业务进行分析。

在本系统中的每个功能的实现的开发顺序依次为需求分析、原型设计、前端页面设计、数据库设计、后端开发、前端数据绑定、功能逻辑完善、功能测试，其中数据库设计、后端开发为并行的开发流程，前端数据绑定、功能逻辑完善为并行的开发流程。在各个流程之间采用流水线作业的方式，以最大化团队的工作效率。

- 缺一个迭代图（后补）

## 需求

在本系统中，需求可以概述为为消费者提供人性化的选购方案、为店员提供易于理解的执行方案、为店主提供可视化的数据展示方案。具体地，需求可以通过客户端需求、管理端需求、系统全局需求三个方面来进行描述。

第一，客户端需求。作为一名顾客，在选购商品时的满意程度取决于操作界面是否友好、选购所耗费的时间是否在预期之中、选购过程中是否遇到操作逻辑上的不合理。因此本系统的客户端需要能增添商品到购物车中、从购物车中删除商品、个性化选择商品的可选项、没有非必要的操作步骤、界面能吸引顾客进行消费等。更具体地，客户端的需求可以细化为以下方面：

1. 在不同商品类别中跳转，使顾客可以自由查看每一种类别的商品列表
2. 展示单个商品的详细信息，包括商品名称、商品图片、商品价格、商品描述、饮品温度、饮品甜度、是否在售、上架日期。
3. 调整单个商品的可选项，包括饮品温度、饮品甜度、商品数量。
4. 将单个商品加入购物车中，保证购物车中的商品任然保留顾客选择的可选项信息
5. 将不同类别商品加入购物车中，保证不同类别商品能在购物车中同时存在
6. 购物车中能计算当前已选择的商品总价格，展示当前已选择商品的基本信息
7. 购物车中能删除单个商品，并不影响购物车中其他商品的信息
8. 购物车不允许结算不合法的订单，例如空的订单、为选择支付方式的订单
9. 在点击购物车中的结算按钮后跳转至对应支付方式的支付页面进行支付
10. 支持二维码或账号密码验证支付
11. 在每份订单支付完成时对购物车进行清空
12. 支持多个不同终端同时下单支付

第二，管理端需求。作为一名咖啡店的咖啡师，在浏览订单列表时的满意程度取决于订单中每一个饮品的信息是否清晰完整、订单更新是否及时、查询订单是否便捷。作为一名咖啡店的店长，一定希望能更便捷快速地增添、删除、修改商品信息，可视化查看咖啡店的收入分析情况。因此本系统的管理端需要能快速浏览待完成的订单详细信息、更改订单完成状态、查询订单信息、增添在售上的商品、从销售列表中移除商品、更改商品的信息、查看收入分析等。更具体地，管理端的需求可以细化为以下方面：

1. 展示订单列表
2. 动态更新订单的支付状态与完成状态
3. 展示每个订单的详细信息，包括饮品名称、可选项需求等
4. 根据订单中包含的商品名称筛选订单
5. 根据订单生成时间范围筛选订单
6. 展示在售的商品信息
7. 修改单个商品详细信息，包括类别、名称、饮品温度、饮品甜度、是否在售、价格、描述
8. 删除单个商品
9. 增添单个商品并上传商品图片
10. 展示收入统计信息，包括本日收入、七日收入、本日饮品排行、本月收入、本年收入

第三，系统全局需求。作为一个完整的管理系统，需要保证稳定运行、信息安全、运行效率。更具体地，系统全局需求可以细化为以下方面：

1. 对重要的数据传输做RSA与AES联合加密
2. 在设计中绝对避免将支付接口暴露
3. 在系统接口的设计上进行数据验证，防止SQL注入
4. 系统需要可以同时监听多份订单的支付状态
5. 使用合理的数据表结构，以便进行数据统计

## 设计

本系统原型设计axure和figma进行设计，功能设计选择Vue3和Element作为前端框架，Node.js作为后端的框架，MySQL作为数据库进行开发。

本系统用户端的原型设计分为商品展示-购物车两个界面。对于商品展示界面，我们团队选择了以卡片的形式来展示商品，以不同的字体大小，配合图片来突出商品的相关信息，比如价格、名称等。以系列为标准对多个商品卡片进行分组，方便用户在自己喜欢的饮品种类下挑选商品。同时我们也为位于商品界面的购物车指示栏设计了动态的数字展示，以提醒用户当前购物车中所包含的商品数量。对于商品详细界面的挑选，我们团队采取了列表式的设计，便于用户清晰直观的选择商品属性。对于购物车界面，我们选择采用表格式的展示方法，这样能够便利用户直观的看到自己所选择的商品名字、属性、价格以及账单的总金额。

本系统管理端的原型设计从后台管理的需求出发，将管理端分为账单详情-商品设置-数据统计三个界面。对于账单界面，我们团队采用直观的列表形式展示账单数据，包括账单编号、生成时间、饮品当前状态、账单当前状态以及详情按钮。详情页展示了单个账单的更多信息，在列表已展示的数据基础上补充了饮品名称、属性、数量等相关信息。我们还在账单界面设计了条件筛选窗口，已便于根据时间或者商品名称快速定位需要的账单。对于商品设置界面，我们团队沿用了用户端商品展示界面的设计，并在此基础上添加了单个商品信息修改的入口，管理人员可以对商品进行添加或删除，或者修改商品的种类、名称、属性、价格等信息，还可以选择是否上架商品。对于数据统计界面，我们团队选择展示常用的统计数据，包括七日收入统计、本日收入统计、类型收入统计、单品收入统计等。同时我们采用了多种设计图表展示统计数据，包括饼图、柱状图、折线图等。

本系统的数据库采用MySQL进行构建，使用Sequelize连接MySQL数据库。数据库中包含两个数据表，分别用于村春商品信息和订单信息。商品信息的数据表包含的字段为商品名称、商品列表、商品可选项、是否在售、商品图片文件名、商品图片占位图、商品价格、商品描述，其中商品可选项为JSON类型。订单信息的数据表包含的字段为订单编号、订单支付状态、订单完成状态、订单中包含的商品信息、订单支付方式、订单总金额，其中订单中包含的商品信息为JSON类型。

本系统的绝大部分数据都存储于MySQL数据库中，但是商品的图片是个例外。由于商品图片较大，转换成base64后无法存入MySQL数据库，因此本系统将商品图片存于系统后端的目录下，再在数据库中存储商品图片在后端的对应文件名，在前端请求商品数据时通过对应图片的路径将其读出并和数据库中其他商品信息一起相应给前端。

本系统使用Vue3框架开发客户端和管理端的前端界面，组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。在系统的客户端中，前端的组件开发分为了首页组件、商品列表组件、商品详情组件、购物车组件、支付回调组件。在系统的管理端中，前端的组件开发分为了首页组件、订单列表组件、订单详情组件、商品列表组件、商品详情组件、增加商品组件、本日收入组件、七日收入组件、本日饮品排行组件、本月收入组件、本年收入组件。

本系统的前端使用Element组件库进行设计，使用了卡片、表格、按钮、输入框、选择器等组件作为与用户交互的组件，在管理端的收入统计中，使用了echart进行数据展示。本系统的前端使用axios调取接口，异步处理接口相应的数据。

本系统的后端使用Node.js中的Express框架，其优势在于Express可以设置中间件来响应 HTTP 请求，且定义了路由表用于执行不同的 HTTP 请求动作。后端接口的设计分为商品信息接口、订单信息接口与商品图片接口三类，支付接口不在后端暴露，而是作为生成订单时同时执行的一个中间件。

本系统后端中关于商品信息的接口设计如下：

1. 添加商品，post类型，请求携带的数据为需要添加的商品信息，响应已添加的商品信息
2. 获取所有商品信息，get类型，无参数，响应所有商品信息
3. 获取单个商品信息，get类型，参数为需要获取信息的商品名称，响应对应名称的商品信息
4. 获取一类商品的所有信息，get类型，参数为需要获取信息的商品类别名，响应对应类别的商品信息
5. 更新单个商品信息，put类型，参数为需要更新的商品信息，响应更新后的商品信息
6. 删除单个商品，delete类型，参数为需要删除的商品编号，响应已删除的商品个数
7. 删除所有商品，delete类型，无参数，响应已删除的商品个数

本系统后端中关于订单信息的接口设计如下：

1. 生成新的订单，post类型，参数为需要生成的订单信息，在生成订单后调取支付接口，并持续监听订单支付状态，响应支付页面链接
2. 获取所有订单信息，get类型，无参数，响应所有订单信息
3. 更新单个订单信息，put类型，参数为需要更新的订单信息，响应更新后的订单信息
4. 删除单个订单，delete类型，参数为需要删除的订单编号，响应已删除的订单个数
5. 删除所有订单，delete类型，无参数，响应已删除的订单个数
6. 根据关键字筛选订单，post类型，参数为关键字列表，响应包含关键字的所有订单信息
7. 根据订单生成时间范围筛选订单，post类型，参数为开始时间与结束时间，响应在该时间段中的所有订单信息
8. 根据订单编号获取订单信息，post类型，参数为订单编号，响应该订单信息
9. 获取近7日的每日收入，post类型，无参数，响应近7日的每日收入
10. 获取当日所有订单信息，post类型，无参数，响应当日所有订单信息
11. 获取近一年的每月收入，post类型，无参数，响应近一年的每月收入
12. 获取所有未支付的订单信息，post类型，无参数，响应所有未支付的订单信息
13. 更改指定订单的完成状态，post类型，参数为订单编号，响应已更改的订单信息
14. 获取所有商品的单月销量，post类型，无参数，响应所有商品的单月销量

本系统后端中关于商品图片的接口设计如下：

1. 储存上传的文件，post类型，参数为需要储存的文件流，响应储存状态
2. 获取已上传的文件列表，get类型，无参数，响应已上传的文件列表
3. 下载指定文件，get类型，参数为文件名称，响应可下载文件流

关于系统的安全性设计，我们采用对后端重要的数据传输做RSA与AES联合加密的方式，以保证关键信息即使被抓包也不会马上被破解。RSA并不适合加密大数据，而是先生成一个随机的AES密码，用AES加密原始信息，然后用RSA加密AES口令。对于本系统而言，支付接口回调的信息是较为重要的信息，而支付接口回调的信息具有一定的时效性，只需要将支付接口的超时时间设置的比使用生日攻击爆破RSA密钥的最理想时间短，就可以在非常大程度上做到数据的相对安全。

## 概念验证的编码和集成

在系统客户端的开发中，我们团队完成了所有已提出的需求，包括用户下单饮品、用户自定义饮品可选项、订单结账。在开发购物车组件时，我们发现购物车所需要的数据位于商品详情组件中，而购物车组件与商品详情组件相距了三层组件，数据传输过于繁琐。我们对订单数据进行了重新设计，将其置于首页组件下，并使用依赖注入到购物车组件与商品详情组件中。无论订单数据在商品详情页中更新还是在购物车中更新，都能同步更新到同一个组件中的数据上，避免了重复更新的漏洞。

在系统管理端的开发中，我们团队完成了绝大部分已提出的需求，包括订单列表展示、订单详情展示、订单条件筛选、商品信息更改、收入情况分析。在收入分析功能的开发中，由于我们团队并没有咖啡店长期的营收数据，因此使用了互联网上的一些样例数据来展示我们对订单数据进行收入分析的功能。

在系统后端的开发中，我们团队完成了绝大部分已提出的需求，包括对重要的数据传输做RSA与AES联合加密、在设计中绝对避免将支付接口暴露、同时监听多份订单的支付状态、具有合理的数据表结构。在设计管理端收入分析的接口时，发现前期设计的存储订单数据的数据表结构不利于直接使用MySQL语句查询一段时间的销售量，对储存订单数据的数据表结构进行了重新设计，使后端能使用Sequelize连接MySQL数据库后使用MySQL语句直接查询收入数据。

以下是系统中更为详细的设计细节：

1. 在生成订单后调取支付接口，避免将支付接口暴露

   在后端订单创建的接口中，同时调用支付接口，响应支付接口返回的支付链接，达到了不将支付接口直接暴露在后端的目的，防止黑客直接修改订单金额。

    ```javascript
   // order.controller.js
    exports.create = (req, res) => {
        ...
        Orders.create(orders)
        .then(data => {
            alipay.payapi(data.dataValues)
            .then(url=>{
                res.send(url)
                ...
            })
        })
        ...
    };
    ```

   ```javascript
   // alipay.js
   const alipaySdk = new AliPaySdk({
       appId: '20210001XXXXXXXX', 
       ...
     })
   async function paycreate(data){
       const formData = new AlipayForm()
       ...
       const result = await alipaySdk.exec('alipay.trade.page.pay',{},{ formData: formData })
       return result
   }
   exports.payapi = paycreate;
   ```

2. 持续监听订单支付状态

   使用node中的interval循环主动调用支付宝的查询接口，通过订单号查询订单状态，并设置循环次数上限，达到订单超时无效的作用

   ```javascript
   // order.controller.js
   function updatepay(publicid){
     ...
     Orders.update({paytime:showtime}...})
       if(data[0]==1){
         clearInterval(intervalObj[publicid])
       }
     ...
   }
   function updateunpay(publicid,status){
     Orders.update({paytime:status}...})
     ...
   }
   function checkpay(publicid){
     timesRun[publicid] += 1;
     if(timesRun[publicid] === 60){
       clearInterval(intervalObj[publicid])
     }
     ...
       switch(r.trade_status) {
         case 'WAIT_BUYER_PAY':
           updateunpay(publicid,'WAIT_BUYER_PAY')
           break;
         case 'TRADE_SUCCESS':
           updatepay(publicid)
           break;
     ...
   }
   ```

3. 同时监听多份订单的支付状态

   使用两个数组来对订单的监听进程进行管理，将interval进程作为对象存于数组中，并可以通过该对象终止该监听进程。

   ```javascript
   // order.controller.js
   var intervalObj=new Array();
   var timesRun=new Array()
   ...
   timesRun[data.dataValues.publicid]=0
   intervalObj[data.dataValues.publicid]=setInterval(checkpay, 2000, data.dataValues.publicid);
   ...
   ```

4. 储存上传的商品图片

   使用异步函数接收图片的文件流，以下为该功能的中间件

   ```javascript
   // upload.js
   let storage = multer.diskStorage({
     destination: (req, file, cb) => {
       cb(null, __basedir + "/uploads/");
     },
     filename: (req, file, cb) => {
       console.log(file.originalname);
       cb(null,file.originalname);
     },
   });
   let uploadFile = multer({
     storage: storage,
     limits: { fileSize: maxSize },
   }).single("file")
   let uploadFileMiddleware = util.promisify(uploadFile);
   module.exports = uploadFileMiddleware;
   ```

   

5. 对重要的数据传输的RSA与AES联合加密

   使用AES对信息进行对称加密，用RSA对AES的密钥进行非对称加密，传输的数据包括AES加密后的信息与RSA加密后的AES解码的密钥，以此保证重要数据的安全。其中RSA使用node.js中的node-rsa库实现。

   ```javascript
   // encrypt
   const AES_encrypted=AESEncrypt(data, aes_key)
   const RSA_encrypted = crypto.publicEncrypt(aes_key, Buffer.from(text)).toString("base64");
   // decrypt
   const RSA_decrypted = crypto.privateDecrypt({
       key: privateDer,
       padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
   },
       Buffer.from(aes_key, "base64")
   ).toString("utf8");
   const AES_decrypted=AESEncrypt(AES_encrypted, RSA_decrypted)
   ```

   

## 测试和评估

本系统的客户端与管理端在完成后打包为桌面应用程序的安装程序，在团队内进行了第一轮内部测试。在修补已发现的漏洞后，在学生中随机寻找适当人数帮助我们团队进行测试，一部分人扮演顾客进行点单、一部分人扮演咖啡师完成订单、一部分人扮演店长对商品信息进行修改。在经过一系列测试后，我们得到了以下的反馈：

## 结论和未来工作

本系统达到了项目设计的基础要求，提供了一个顾客可以点单、咖啡师可以查看订单、店长可以管理商品和查看收入分析的咖啡店管理系统。本系统还欠缺一个可以存储账号的数据库，用于检验用户账号，以此达到可以将系统分发至每一个顾客的终端上的目的。在我们团队的设计中，本系统还可以有以下方面的拓展：

1. 客户端的商品智能推荐。从本系统的订单数据库获取携带时间信息的商品销售数据，可以考虑由以下两个方面进行商品只能推荐。第一，根据天气情况和当下时间进行推荐，包括但不限于温度、湿度、降水量等，系统在记录每一个订单信息时可以同时从互联网中获取当时的天气情况，并与订单信息一同存入数据库中。当数据达到一定量时，将天气情况（温度、湿度、降水量等）与当下时间作为自变量，饮品名称作为因变量，构建多分类训练数据集。使用XGBoost这种将许多弱决策树集成在一起形成一个强的分类预测模型的机器学习模型进行训练，得到可以根据多维度的天气情况与当下时间输出饮品名称的预测模型。此时就可以在后端直接从互联网获取当下的天气情况与时间，得到推荐的饮品，并将其完整信息在客户端进行渲染推荐给顾客。第二，在拥有账号系统后，可以对用户行为进行时间序列的分析，从而进行个性化推荐饮品。具体地，使用来自同一用户的订单中的商品信息构建时间序列，当该时间序列足够大并具有统计意义时，对其使用LBGM进行训练或使用TCN进行训练。训练后的模型或网络均具有预测能力，能针对该用户个性化推荐饮品。并且该预测模型的预测能力随着用户的使用次数增长将会不断优化，达到学习用户的行为进行推荐的目的。
2. 管理端的商品成本计算与导出财务报表。通过增加商品数据库中的成本数据，可以在管理端对咖啡店的更多营收数据进行分析，包括但不限于店铺营业额、销售额、毛利率、增值税等。可以按照该国家的税务格式要求导出标准格式的财务报表。
3. 系统后端的处理多并发。在增加用户账号系统后，系统将被分发至每一个顾客的终端上。随着用户数量的增长，系统后端服务器的运算压力也随之上升。为了更好的解决这一问题，系统后端将进行进一步优化，在并发量较小时可以使用异步操作来应对多并发。异步在 I/O 资源的利用上可以实现并发， 但是异步无法并发的使用 CPU 资源。多进程才能更好地利用多核操作系统的优点。本系统Node.js后端可以使用 Cluster 模块来完成多进程。在多进程都无法满足服务器并发量时，可以考虑部署分布式后端。
4. 管理端的咖啡师工作调度。在系统经过一段时间的使用后，订单数据库的数据量已经相对庞大。此时可以考虑对每一订单的完成时间进行分析，由系统动态调度咖啡店中的多名咖啡师。该功能有两种实现方法。第一种，首先计算出每个商品由每名咖啡师完成的平均完成时间。接着，根据咖啡店场景列出动态规划的状态转移方程。然后，将即时的待完成订单的状态带入状态转移方程，求解该场景下的局部最优解，并将任务分发至每一名咖啡师。第二种，根据咖啡店场景的影响因素构建openai/gym环境，使用Policy-Based Reinforcement Learning 对过去所有environment 中的state进行训练，得到最有的policy function，从而对当下状态进行全局最优解的决策。使用系统工作调度还有一个优势，能更方便地对每一名咖啡师的工作进行绩效考核。